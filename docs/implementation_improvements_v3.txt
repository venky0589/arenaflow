}

// Example usage
if (tournament.getStartDate().isBefore(LocalDate.now())) {
    throw new BusinessRuleViolationException("Tournament start date cannot be in the past");
}
```

#### E. API Documentation Enhancement
```java
// Enhance Swagger/OpenAPI annotations
@Operation(
    summary = "Create a new tournament",
    description = "Creates a tournament with categories and courts. Requires ADMIN role.",
    responses = {
        @ApiResponse(responseCode = "201", description = "Tournament created successfully"),
        @ApiResponse(responseCode = "400", description = "Invalid input"),
        @ApiResponse(responseCode = "403", description = "Insufficient permissions")
    }
)
@SecurityRequirement(name = "bearer-jwt")
@PostMapping
ResponseEntity<TournamentResponse> createTournament(
    @Valid @RequestBody CreateTournamentRequest request
) { }
```

### 3. **Database & Query Optimization**

#### A. Add Strategic Indexes
```sql
-- Migration: V2__add_indexes.sql
CREATE INDEX idx_match_tournament ON match(tournament_id);
CREATE INDEX idx_match_status ON match(status);
CREATE INDEX idx_match_court_time ON match(court_id, scheduled_time);
CREATE INDEX idx_registration_tournament_player ON registration(tournament_id, player_id);
CREATE INDEX idx_tournament_dates ON tournament(start_date, end_date);

-- Composite indexes for common queries
CREATE INDEX idx_match_tournament_status ON match(tournament_id, status);
CREATE INDEX idx_registration_tournament_category ON registration(tournament_id, category_id);
```

#### B. Use Projections for Efficient Queries
```java
// Instead of loading full entities
// Bad: 
List<Match> matches = matchRepository.findByTournamentId(tournamentId);

// Good: Use projections
interface MatchSummary {
    Long getId();
    String getPlayer1Name();
    String getPlayer2Name();
    LocalDateTime getScheduledTime();
    String getStatus();
}

@Query("""
    SELECT m.id as id, 
           p1.name as player1Name,
           p2.name as player2Name,
           m.scheduledTime as scheduledTime,
           m.status as status
    FROM Match m
    JOIN m.player1 p1
    JOIN m.player2 p2
    WHERE m.tournament.id = :tournamentId
    """)
List<MatchSummary> findMatchSummariesByTournamentId(@Param("tournamentId") Long tournamentId);
```

#### C. Implement Pagination Properly
```java
@GetMapping
ResponseEntity<Page<TournamentResponse>> getTournaments(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "20") int size,
    @RequestParam(defaultValue = "startDate") String sortBy,
    @RequestParam(defaultValue = "DESC") Sort.Direction direction
) {
    Pageable pageable = PageRequest.of(page, size, Sort.by(direction, sortBy));
    Page<Tournament> tournaments = tournamentRepository.findAll(pageable);
    return ResponseEntity.ok(tournaments.map(mapper::toResponse));
}
```

#### D. Use Database Constraints
```sql
-- Add constraints for data integrity
ALTER TABLE match 
ADD CONSTRAINT check_valid_score 
CHECK (player1_score >= 0 AND player2_score >= 0);

ALTER TABLE tournament
ADD CONSTRAINT check_valid_dates
CHECK (end_date >= start_date);

ALTER TABLE match
ADD CONSTRAINT check_different_players
CHECK (player1_id != player2_id);

-- Unique constraints
ALTER TABLE registration
ADD CONSTRAINT unique_player_tournament_category
UNIQUE (player_id, tournament_id, category_id);
```

### 4. **Security Enhancements**

#### A. Fine-Grained Authorization
```java
@Configuration
@EnableMethodSecurity
class SecurityConfig {
    @Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**", "/api/v1/tournaments/public/**").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.POST, "/api/v1/tournaments/*/score")
                    .hasAnyRole("ADMIN", "REFEREE")
                .requestMatchers(HttpMethod.POST, "/api/v1/registrations")
                    .hasAnyRole("USER", "ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))
            .csrf(csrf -> csrf.ignoringRequestMatchers("/api/**")); // Use CSRF tokens in production
        
        return http.build();
    }
}

// Method-level security
@PreAuthorize("hasRole('ADMIN') or @securityService.isMatchReferee(#matchId, authentication)")
public void updateScore(Long matchId, ScoreUpdate scoreUpdate) { }
```

#### B. Rate Limiting
```java
@Component
class RateLimitInterceptor implements HandlerInterceptor {
    private final RateLimiter rateLimiter;
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) {
        String clientId = getClientId(request);
        
        if (!rateLimiter.tryAcquire(clientId)) {
            response.setStatus(429); // Too Many Requests
            return false;
        }
        return true;
    }
}

// Or use bucket4j library
@RateLimiter(name = "authAPI", fallbackMethod = "rateLimitFallback")
@PostMapping("/login")
public ResponseEntity<?> login(@RequestBody LoginRequest request) { }
```

#### C. Input Sanitization
```java
// Add validation annotations
record CreatePlayerRequest(
    @NotBlank @Size(min = 2, max = 100) String name,
    @Email String email,
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$") String phone,
    @PastOrPresent LocalDate dateOfBirth
) {}

// Sanitize user input
@Component
class InputSanitizer {
    public String sanitizeHtml(String input) {
        return Jsoup.clean(input, Safelist.basic());
    }
}
```

#### D. Audit Trail
```java
@Entity
@EntityListeners(AuditingEntityListener.class)
class AuditLog {
    @Id @GeneratedValue
    private Long id;
    
    private String entityType;
    private Long entityId;
    private String action; // CREATE, UPDATE, DELETE
    private String userId;
    private LocalDateTime timestamp;
    
    @Column(columnDefinition = "TEXT")
    private String changes; // JSON of old/new values
}

// Usage with Spring Data JPA Auditing
@Entity
@EntityListeners(AuditingEntityListener.class)
class Tournament {
    @CreatedBy
    private String createdBy;
    
    @CreatedDate
    private LocalDateTime createdAt;
    
    @LastModifiedBy
    private String lastModifiedBy;
    
    @LastModifiedDate
    private LocalDateTime lastModifiedAt;
}
```

### 5. **Frontend Architecture Improvements**

#### A. State Management Enhancement
```typescript
// Current: Likely prop drilling or no centralized state
// Improvement: Use Context API or Zustand

// Context API approach
interface TournamentContextType {
  tournaments: Tournament[];
  selectedTournament: Tournament | null;
  loading: boolean;
  error: string | null;
  fetchTournaments: () => Promise<void>;
  selectTournament: (id: number) => void;
}

const TournamentContext = createContext<TournamentContextType | null>(null);

export const TournamentProvider: React.FC<{children: ReactNode}> = ({children}) => {
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [selectedTournament, setSelectedTournament] = useState<Tournament | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchTournaments = async () => {
    setLoading(true);
    try {
      const data = await api.getTournaments();
      setTournaments(data);
      setError(null);
    } catch (err) {
      setError('Failed to fetch tournaments');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <TournamentContext.Provider value={{
      tournaments, selectedTournament, loading, error,
      fetchTournaments, selectTournament
    }}>
      {children}
    </TournamentContext.Provider>
  );
};

// Or use Zustand (simpler, better performance)
import create from 'zustand';

interface TournamentStore {
  tournaments: Tournament[];
  loading: boolean;
  fetchTournaments: () => Promise<void>;
}

export const useTournamentStore = create<TournamentStore>((set) => ({
  tournaments: [],
  loading: false,
  fetchTournaments: async () => {
    set({ loading: true });
    const data = await api.getTournaments();
    set({ tournaments: data, loading: false });
  }
}));
```

#### B. API Client Architecture
```typescript
// Current: Axios scattered across components
// Improvement: Centralized API client with interceptors

// api/client.ts
import axios, { AxiosInstance } from 'axios';

class ApiClient {
  private client: AxiosInstance;
  
  constructor() {
    this.client = axios.create({
      baseURL: import.meta.env.VITE_API_BASE,
      timeout: 10000,
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // Request interceptor - add auth token
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('jwt_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // Response interceptor - handle errors globally
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          // Token expired, redirect to login
          localStorage.removeItem('jwt_token');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }
  
  async get<T>(url: string, params?: any): Promise<T> {
    const response = await this.client.get<T>(url, { params });
    return response.data;
  }
  
  async post<T>(url: string, data?: any): Promise<T> {
    const response = await this.client.post<T>(url, data);
    return response.data;
  }
  
  // Add put, delete, patch methods
}

export const apiClient = new ApiClient();

// api/tournaments.ts - Domain-specific APIs
export const tournamentsApi = {
  getAll: () => apiClient.get<Tournament[]>('/tournaments'),
  getById: (id: number) => apiClient.get<Tournament>(`/tournaments/${id}`),
  create: (data: CreateTournamentRequest) => 
    apiClient.post<Tournament>('/tournaments', data),
  generateDraw: (id: number) => 
    apiClient.post<void>(`/tournaments/${id}/generate-draw`)
};
```

#### C. Custom Hooks for Reusability
```typescript
// hooks/useTournaments.ts
export function useTournaments() {
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchTournaments = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await tournamentsApi.getAll();
      setTournaments(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, []);
  
  useEffect(() => {
    fetchTournaments();
  }, [fetchTournaments]);
  
  return { tournaments, loading, error, refetch: fetchTournaments };
}

// hooks/useMatch.ts
export function useMatch(matchId: number) {
  const [match, setMatch] = useState<Match | null>(null);
  const [updating, setUpdating] = useState(false);
  
  const updateScore = async (score: ScoreUpdate) => {
    setUpdating(true);
    try {
      await matchesApi.updateScore(matchId, score);
      // Optimistically update UI
      setMatch(prev => prev ? {...prev, ...score} : null);
    } finally {
      setUpdating(false);
    }
  };
  
  return { match, updateScore, updating };
}
```

#### D. Form Handling Improvement
```typescript
// Current: Might be using basic useState
// Improvement: Use React Hook Form + Zod validation

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Define schema
const tournamentSchema = z.object({
  name: z.string().min(3, 'Name must be at least 3 characters'),
  startDate: z.date().min(new Date(), 'Start date must be in future'),
  endDate: z.date(),
  format: z.enum(['SINGLE_ELIMINATION', 'ROUND_ROBIN']),
  categories: z.array(z.object({
    name: z.string(),
    maxParticipants: z.number().positive()
  })).min(1, 'At least one category required')
}).refine(data => data.endDate >= data.startDate, {
  message: 'End date must be after start date',
  path: ['endDate']
});

type TournamentFormData = z.infer<typeof tournamentSchema>;

function CreateTournamentForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<TournamentFormData>({
    resolver: zodResolver(tournamentSchema)
  });
  
  const onSubmit = async (data: TournamentFormData) => {
    await tournamentsApi.create(data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <TextField
        {...register('name')}
        error={!!errors.name}
        helperText={errors.name?.message}
        label="Tournament Name"
      />
      {/* Other fields */}
    </form>
  );
}
```

#### E. Component Organization
```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ common/           # Reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DataTable/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FormField/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Modal/
‚îÇ   ‚îú‚îÄ‚îÄ tournaments/      # Domain-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TournamentList/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TournamentForm/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BracketView/
‚îÇ   ‚îî‚îÄ‚îÄ layout/           # Layout components
‚îÇ       ‚îú‚îÄ‚îÄ Navbar/
‚îÇ       ‚îú‚îÄ‚îÄ Sidebar/
‚îÇ       ‚îî‚îÄ‚îÄ Footer/
‚îú‚îÄ‚îÄ pages/                # Page components
‚îÇ   ‚îú‚îÄ‚îÄ TournamentsPage.tsx
‚îÇ   ‚îú‚îÄ‚îÄ MatchesPage.tsx
‚îÇ   ‚îî‚îÄ‚îÄ DashboardPage.tsx
‚îú‚îÄ‚îÄ hooks/                # Custom hooks
‚îú‚îÄ‚îÄ api/                  # API clients
‚îú‚îÄ‚îÄ types/                # TypeScript types
‚îú‚îÄ‚îÄ utils/                # Utility functions
‚îî‚îÄ‚îÄ contexts/             # React contexts
```

### 6. **Mobile App Improvements**

#### A. Better State Persistence
```typescript
// Current: Basic AsyncStorage
// Improvement: Use MMKV (faster) or persist entire state

import { MMKV } from 'react-native-mmkv';

const storage = new MMKV();

// Persist auth state
export const authStorage = {
  getToken: () => storage.getString('jwt_token'),
  setToken: (token: string) => storage.set('jwt_token', token),
  clearToken: () => storage.delete('jwt_token'),
};

// Persist entire Zustand store
import { persist, createJSONStorage } from 'zustand/middleware';

export const useAuthStore = create(
  persist(
    (set) => ({
      token: null,
      user: null,
      login: async (credentials) => { /* ... */ },
      logout: () => set({ token: null, user: null })
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => ({
        getItem: (key) => storage.getString(key),
        setItem: (key, value) => storage.set(key, value),
        removeItem: (key) => storage.delete(key)
      }))
    }
  )
);
```

#### B. Offline Queue System
```typescript
// Queue score updates when offline
interface QueuedRequest {
  id: string;
  endpoint: string;
  method: string;
  data: any;
  timestamp: number;
}

class OfflineQueue {
  private queue: QueuedRequest[] = [];
  
  async add(request: Omit<QueuedRequest, 'id' | 'timestamp'>) {
    const queued: QueuedRequest = {
      ...request,
      id: uuid(),
      timestamp: Date.now()
    };
    
    this.queue.push(queued);
    await this.saveQueue();
    
    // Try to process immediately if online
    if (await this.isOnline()) {
      this.processQueue();
    }
  }
  
  async processQueue() {
    const toProcess = [...this.queue];
    for (const request of toProcess) {
      try {
        await apiClient.request(request);
        this.removeFromQueue(request.id);
      } catch (error) {
        console.error('Failed to process queued request', error);
      }
    }
  }
}
```

#### C. Better Error Handling
```typescript
// Network-aware error handling
import NetInfo from '@react-native-community/netinfo';

function useNetworkAwareApi() {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsOnline(state.isConnected ?? false);
    });
    return unsubscribe;
  }, []);
  
  const makeRequest = async (apiCall: () => Promise<any>) => {
    if (!isOnline) {
      throw new Error('No internet connection. Request will be queued.');
    }
    
    try {
      return await apiCall();
    } catch (error) {
      if (error.message.includes('Network')) {
        // Queue for later
        await offlineQueue.add(/* ... */);
      }
      throw error;
    }
  };
  
  return { isOnline, makeRequest };
}
```

### 7. **Testing Improvements**

#### A. Backend Testing Strategy
```java
// Integration tests with Testcontainers
@SpringBootTest
@Testcontainers
class TournamentServiceIntegrationTest {
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("testdb");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired TournamentService service;
    @Autowired TournamentRepository repository;
    
    @Test
    @Transactional
    void shouldCreateTournamentWithCategories() {
        // Given
        CreateTournamentCommand cmd = new CreateTournamentCommand(
            "Test Tournament",
            LocalDate.now().plusDays(7),
            LocalDate.now().plusDays(10),
            List.of(new CategoryRequest("Men's Singles", TournamentFormat.SINGLE_ELIMINATION))
        );
        
        // When
        Tournament result = service.createTournament(cmd);
        
        // Then
        assertThat(result.getId()).isNotNull();
        assertThat(result.getCategories()).hasSize(1);
        assertThat(repository.findById(result.getId())).isPresent();
    }
}

// Unit tests with mocks
@ExtendWith(MockitoExtension.class)
class DrawGenerationServiceTest {
    @Mock TournamentRepository tournamentRepo;
    @Mock MatchRepository matchRepo;
    @InjectMocks DrawGenerationService service;
    
    @Test
    void shouldGenerateSingleEliminationBracket() {
        // Given
        Tournament tournament = createTestTournament();
        List<Registration> registrations = createTestRegistrations(8);
        when(tournamentRepo.findById(1L)).thenReturn(Optional.of(tournament));
        
        // When
        service.generateDraw(1L, 1L);
        
        // Then
        verify(matchRepo, times(7)).saveAll(anyList()); // 8 players = 7 matches
    }
}
```

#### B. Frontend Testing
```typescript
// Component testing with React Testing Library
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { TournamentList } from './TournamentList';

describe('TournamentList', () => {
  it('should display tournaments after loading', async () => {
    // Mock API
    jest.spyOn(tournamentsApi, 'getAll').mockResolvedValue([
      { id: 1, name: 'Summer Tournament', startDate: '2025-06-01' }
    ]);
    
    render(<TournamentList />);
    
    // Should show loading initially
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
    
    // Should show tournaments after load
    await waitFor(() => {
      expect(screen.getByText('Summer Tournament')).toBeInTheDocument();
    });
  });
  
  it('should navigate to tournament detail on row click', async () => {
    const mockNavigate = jest.fn();
    jest.mock('react-router-dom', () => ({
      useNavigate: () => mockNavigate
    }));
    
    render(<TournamentList />);
    
    const row = await screen.findByText('Summer Tournament');
    await userEvent.click(row);
    
    expect(mockNavigate).toHaveBeenCalledWith('/tournaments/1');
  });
});

// E2E testing with Playwright
import { test, expect } from '@playwright/test';

test('admin can create tournament', async ({ page }) => {
  // Login
  await page.goto('http://localhost:5173/login');
  await page.fill('[name="email"]', 'admin@example.com');
  await page.fill('[name="password"]', 'admin123');
  await page.click('button[type="submit"]');
  
  // Navigate to tournaments
  await page.click('text=Tournaments');
  await page.click('text=Create New');
  
  // Fill form
  await page.fill('[name="name"]', 'Winter Championship');
  await page.fill('[name="startDate"]', '2025-12-01');
  await page.click('button:has-text("Save")');
  
  // Verify creation
  await expect(page.locator('text=Winter Championship')).toBeVisible();
});
```

### 8. **Performance Optimization**

#### A. Backend Caching
```java
@Configuration
@EnableCaching
class CacheConfig {
    @Bean
    CacheManager cacheManager() {
        return new CaffeineCacheManager("tournaments", "players", "matches");
    }
}

@Service
class TournamentService {
    @Cacheable(value = "tournaments", key = "#id")
    public Tournament findById(Long id) {
        return repository.findById(id).orElseThrow();
    }
    
    @CacheEvict(value = "tournaments", key = "#result.id")
    public Tournament update(Long id, UpdateTournamentCommand cmd) {
        // Update logic
    }
    
    @Caching(evict = {
        @CacheEvict(value = "tournaments", allEntries = true),
        @CacheEvict(value = "matches", key = "#result.id")
    })
    public Match updateMatchScore(Long matchId, ScoreUpdate score) {
        // Update logic
    }
}
```

#### B. Frontend Performance
```typescript
// React.memo for expensive components
export const BracketView = React.memo(({ tournamentId }: Props) => {
  // Expensive bracket rendering
}, (prevProps, nextProps) => {
  return prevProps.tournamentId === nextProps.tournamentId;
});

// Virtualization for large lists
import { FixedSizeList } from 'react-window';

function PlayerList({ players }: { players: Player[] }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={players.length}
      itemSize={60}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>
          <PlayerCard player={players[index]} />
        </div>
      )}
    </FixedSizeList>
  );
}

// Lazy loading routes
const TournamentDetail = lazy(() => import('./pages/TournamentDetail'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/tournaments/:id" element={<TournamentDetail />} />
      </Routes>
    </Suspense>
  );
}
```

### 9. **Monitoring & Observability**

#### A. Logging
```java
// Structured logging with logback
@Slf4j
@Service
class TournamentService {
    public Tournament createTournament(CreateTournamentCommand cmd) {
        log.info("Creating tournament: name={}, startDate={}", 
                 cmd.getName(), cmd.getStartDate());
        
        try {
            Tournament result = // ... creation logic
            log.info("Tournament created successfully: id={}", result.getId());
            return result;
        } catch (Exception e) {
            log.error("Failed to create tournament: name={}", cmd.getName(), e);
            throw e;
        }
    }
}
```

#### B. Metrics
```java
// Using Micrometer
@Service
class TournamentService {
    private final MeterRegistry meterRegistry;
    private final Counter tournamentCreations;
    
    public TournamentService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.tournamentCreations = Counter.builder("tournaments.created")
            .description("Number of tournaments created")
            .register(meterRegistry);
    }
    
    public Tournament createTournament(CreateTournamentCommand cmd) {
        Tournament result = // ... creation
        tournamentCreations.increment();
        return result;
    }
}
```

### 10. **Deployment Enhancements**

#### A. Docker Multi-Stage Build
```dockerfile
# Backend Dockerfile
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn clean package -DskipTests

FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]

# Frontend Dockerfile
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
```

#### B. CI/CD Pipeline
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  backend-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: testdb
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
        ports:
          - 5432:5432
          
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      - name: Run tests
        run: cd backend && mvn test
      - name: Build
        run: cd backend && mvn package -DskipTests
        
  frontend-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Test admin-ui
        run: cd admin-ui && npm ci && npm test
      - name: Test user-ui
        run: cd user-ui && npm ci && npm test
        
  deploy:
    needs: [backend-test, frontend-test]
    if: github.ref == '# Implementation Improvements & Best Practices

## üèóÔ∏è Architecture Improvements

### 1. **Backend Architecture Refinements**

#### A. Service Layer Enhancement
**Current**: Basic CRUD services
**Improvement**: Domain-driven design with rich business logic

```java
// Current approach (likely)
@Service
class TournamentService {
    TournamentRepository repo;
    
    Tournament create(Tournament t) { return repo.save(t); }
    Tournament findById(Long id) { return repo.findById(id).orElseThrow(); }
}

// Improved approach
@Service
class TournamentService {
    TournamentRepository repo;
    DrawGenerationService drawService;
    EventPublisher eventPublisher;
    
    @Transactional
    Tournament createTournament(CreateTournamentCommand cmd) {
        // Validation
        validateTournamentDates(cmd);
        validateCourtsAvailability(cmd);
        
        // Business logic
        Tournament tournament = Tournament.builder()
            .name(cmd.getName())
            .startDate(cmd.getStartDate())
            .status(TournamentStatus.DRAFT)
            .build();
            
        Tournament saved = repo.save(tournament);
        
        // Event publishing
        eventPublisher.publish(new TournamentCreatedEvent(saved.getId()));
        
        return saved;
    }
    
    @Transactional
    void startTournament(Long tournamentId) {
        Tournament tournament = findById(tournamentId);
        tournament.validateReadyToStart(); // Domain method
        tournament.start();
        
        // Generate draws for all categories
        drawService.generateAllDraws(tournamentId);
        
        repo.save(tournament);
        eventPublisher.publish(new TournamentStartedEvent(tournamentId));
    }
}
```

#### B. Add Domain Events
**Why**: Decouple business logic and enable extensibility

```java
// Domain Events
@Getter
class TournamentCreatedEvent {
    private final Long tournamentId;
    private final LocalDateTime occurredAt;
}

class MatchCompletedEvent {
    private final Long matchId;
    private final Long winnerId;
    private final Long tournamentId;
}

// Event Handlers
@Component
class TournamentEventHandler {
    @EventListener
    void onTournamentCreated(TournamentCreatedEvent event) {
        // Send welcome emails to organizers
        // Create audit log entry
        // Initialize analytics tracking
    }
    
    @EventListener
    @Transactional
    void onMatchCompleted(MatchCompletedEvent event) {
        // Update player statistics
        // Advance winner to next round
        // Notify spectators
        // Update live leaderboard
    }
}
```

#### C. Implement CQRS Pattern (Optional but Powerful)
**Why**: Separate read and write models for better performance

```java
// Commands (Write side)
record CreateTournamentCommand(String name, LocalDate startDate, ...);
record UpdateMatchScoreCommand(Long matchId, int player1Score, int player2Score);

// Queries (Read side)
record TournamentListQuery(String filter, Pageable pageable);
record BracketQuery(Long tournamentId, Long categoryId);

@Service
class TournamentCommandService { /* Write operations */ }

@Service
class TournamentQueryService { /* Read operations, optimized queries */ }
```

### 2. **API Design Improvements**

#### A. RESTful API Enhancements
**Current**: Basic CRUD endpoints
**Improvement**: Resource-oriented with actions

```java
// Current (assumed)
POST /matches
PUT /matches/{id}

// Improved - Use sub-resources and actions
POST /tournaments/{tournamentId}/matches
PUT /matches/{matchId}/score
POST /matches/{matchId}/start
POST /matches/{matchId}/complete
POST /matches/{matchId}/retire

GET /tournaments/{id}/brackets
GET /tournaments/{id}/schedule
POST /tournaments/{id}/generate-draw
```

#### B. Versioned API
```java
@RestController
@RequestMapping("/api/v1/tournaments")
class TournamentController { }

// When breaking changes needed
@RestController
@RequestMapping("/api/v2/tournaments")
class TournamentControllerV2 { }
```

#### C. Comprehensive DTOs
**Current**: Might be mixing entities and DTOs
**Improvement**: Separate request/response DTOs

```java
// Request DTOs
record CreateTournamentRequest(
    @NotBlank String name,
    @NotNull LocalDate startDate,
    @NotNull LocalDate endDate,
    @NotNull TournamentFormat format,
    @Size(min = 1) List<CreateCategoryRequest> categories
) {}

// Response DTOs with different levels of detail
record TournamentSummaryResponse(Long id, String name, LocalDate startDate, String status) {}

record TournamentDetailResponse(
    Long id, 
    String name, 
    LocalDate startDate, 
    LocalDate endDate,
    String status,
    List<CategoryResponse> categories,
    List<CourtResponse> courts,
    StatisticsResponse statistics
) {}

// Avoid exposing entities directly
// Bad: return repo.findAll(); // Returns JPA entities
// Good: return repo.findAll().stream().map(mapper::toDto).toList();
```

#### D. Error Handling & Validation
```java
@ControllerAdvice
class GlobalExceptionHandler {
    @ExceptionHandler(EntityNotFoundException.class)
    ResponseEntity<ErrorResponse> handleNotFound(EntityNotFoundException ex) {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse(
                "RESOURCE_NOT_FOUND",
                ex.getMessage(),
                LocalDateTime.now()
            ));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    ResponseEntity<ValidationErrorResponse> handleValidation(
        MethodArgumentNotValidException ex
    ) {
        Map<String, String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .collect(Collectors.toMap(
                FieldError::getField,
                error -> error.getDefaultMessage() != null ? error.getDefaultMessage() : "Invalid value"
            ));
        
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(new ValidationErrorResponse("VALIDATION_FAILED", errors));
    }
    
    @ExceptionHandler(BusinessRuleViolationException.class)
    ResponseEntity<ErrorResponse> handleBusinessRule(BusinessRuleViolationException ex) {
        return ResponseEntity
            .status(HttpStatus.UNPROCESSABLE_ENTITY)
            .body(new ErrorResponse("BUSINESS_RULE_VIOLATION", ex.getMessage(), LocalDateTime.now()));
    }
}

// Custom exceptions
class BusinessRuleViolationException extends RuntimeException {
    public BusinessRuleViolationException(String message) {
        super(message);
    }
}

// Example usage
if (tournament.getStartDate().isBefore(LocalDate.now())) {
    throw new BusinessRuleViolationException("Tournament start date cannot be in the past");
}